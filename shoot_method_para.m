function [v_out, Dv_out, faux] = shoot_method_para(v_0,parameters,function_structure)
%[v_out Dv_out] = parallel_shoot_v2(v_0,parameters)
%Use shooting method involve parameter to find closed orbit
%integrating the dynamical system
%from an given initial state until the trajectory intersects
%a given surface defined as the ith nullcline in the same direction as the flow at the
%initial point (meaning the degrees of freedom not corresponding to i move
%in the same direction as originally), having previously also crossed the
%nullcline in the opposite direction. The shooting method aims to find an
%intial state on the nullcline so that the trajectory returns to the same
%point.
%
%The code outputs computes a vector consisting of the mismatch
%between final and intial states on the orbit computed by forward
%integration (effectively, when the initial state is on the nullcline, this
%is the difference between Poincare map A(v_0) and its argument v_0, with
%ith nullcline as the assumed transversal surface that defines the Poincare
%map), concatenated with d/dt[S_R;S_K;N] evaluated at the guess for the
%steady state solution.
%
%If two output arguments are specified, also outputs Jacobian of the first
%output argument as a function of the initial state vector and of a
%parameters   pecified as part of input vector v_0. The parameter type is
%specified as part of the input structure. 
%
%
%Input variables are
%   v_0:     (2*ndegf+1)-by-1 vector containing initial state vector,
%            concatenated with the current guess for
%            the steady state, and the parameter value l in the form.
%   parameters: optional parameter structure with fields
%       t_span: 2-by-1 vector specifying initial and final time for
%               integration;  only needs to be long enough for the
%               trajectory to cross the relevant nullcline with the
%               corresponding flow  component (in the dynamical systems
%               sense) to be in the same direction as at the start of the
%               integration (meaning the dot product of the
%               final flow directions with the normal to the nullcline is
%               of the same sign as the dot product between that normal and
%               the initial flow direction) AFTER having crossed the
%               nullcline once in the opposite direction. Forward
%               integration terminates at that point. 
%       solver: optional substructure with fields
%           methods: string that specifies the matlab ode solver to be used,
%               allows '15s', '23t' and '45'. Defaults to 15s.
%           RelTol: specifies 'RelTol' relative error tolerance passed to
%               matlab ode solver
%           AbsTol: specifies 'AbsTol' absolute error tolerance passed to
%               matlab ode solver
%           delta_v_0: the code displaces the intial conditions by this
%               amount in the flow direction before starting integration,
%               to avoid spurious "return to initial value" right at the
%               start of the integration. Defaults to 100*eps;
%       flags: optional substructure that allows a Jacobian test to be
%               computed. If a field 'test' under flags is set to true, the
%               output v_f is a structure that contains the following
%               fields as generated by Jacobian_test_v2
%           diff:   analytically-computed derivative matrix
%           diff_num: numerically-computed derivative matrix
%           error:  element-wise error in numerically-computed
%                   derivative matrix
%           error_norm: matrix norm of difference between diff and
%                   diff_num, scaled to norm of diff
%       i_crossing: identifies state variable whose nullcline needs to be
%               crossed to cause termination  of integration of ode system
%
%Output:
%   v_out:        difference difference of final state vector and initial state vector
%   Dv_out:       Jacobian of v_out with respect to v_0 (optional)
%   faux:         Optional structure with additional information on closed
%                 orbit, with fields
%       DvP:      When v_0(ndegf+1:2*ndegf) is a fixed point of the Poincare map,
%                 this returns the Jacobian of Poincare map as a
%                 ndegf-by-ndegf matrix; as the Poincare map is defined on a
%                 two-dimensional manifold, DvP has a nullspace (given by
%                 the flow direction of the dynamical system at the fixed
%                 point) and  hence  a zero eigenvalue.
%       t_orbit:  period of orbit

%set mass matrix, Jacobian and event function
if nargout > 1
    options = odeset('Mass',@mass_augmented,'MStateDep','none','Jacobian',@Jacobian_augmented,'RelTol',parameters.solver.RelTol,'AbsTol',parameters.solver.AbsTol,'Events',@crossing);
else
    options = odeset('Mass',@mass,'MStateDep','none','Jacobian',@Jacobian,'RelTol',parameters.solver.RelTol,'AbsTol',parameters.solver.AbsTol,'Events',@crossing);
end    
    
    
%set time span if needed
t_span = parameters.t_span;


%Establish number of degrees of freedom --- this is to facilitate a
%non-problem-specific version of the code in future; obviously
%parameters.ndegf should be 3 here.
parameters.ndegf = (length(v_0)-1)/2;




%set adjustable parameter as specfied by field 'type'
parameters.c = v_0(end);


if nargout > 1
    %Construct augmented initial conditions
    V_0 = zeros(parameters.ndegf*(parameters.ndegf+2),1);
    V_0(1:parameters.ndegf) = v_0(1:parameters.ndegf); %terms corresponding to input state vector
    V_0(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1)) = reshape(eye(parameters.ndegf),parameters.ndegf^2,1); %now add terms corresponding to Jacobian with respect to state vector
else
    V_0 = v_0(1:parameters.ndegf);
end
    
%Event function parameters
%Define parameter for intial evolution of N:
%set which variable crosses its original value to terminate integration
if nargin < 2 || ~isfield(parameters,'i_crossing')
    parameters.i_crossing = parameters.ndegf;   %default to last state variable
end
dv_0dt_init = step(0,v_0(1:parameters.ndegf));
parameters.dir_crossing = sign(dv_0dt_init);
parameters.dir_crossing(parameters.i_crossing) = [];    %define direction of flow for the other degrees of freedom at initial point

%Test Jacobian (optional)
if nargin > 1 && isfield(parameters,'flags') && isfield(parameters.flags,'test') && parameters.flags.test
    if nargout > 1
        if isfield(parameters.flags,'identity') && parameters.flags.identity
            v_out = Jacobian_test_v2(@step_augmented_test,@Jacobian_augmented_test,[ones(parameters.ndegf,1); reshape(eye(parameters.ndegf),parameters.ndegf^2,1); ones(parameters.ndegf,1)],parameters,sqrt(eps));
            v_out.par = Jacobian_test_v2(@step_test_par,@step_par_test_par,v_0(end),ones(parameters.ndegf,1),sqrt(eps));
        elseif isfield(parameters.flags,'local') && parameters.flags.local
            v_out = Jacobian_test_v2(@step_augmented_test,@Jacobian_augmented_test,V_0,parameters,sqrt(eps));
            v_out.par = Jacobian_test_v2(@step_test_par,@step_par_test_par,rand(1),v_0(1:parameters.ndegf),sqrt(eps));
        else
            v_out = Jacobian_test_v2(@step_augmented_test,@Jacobian_augmented_test,rand(size(V_0)),parameters,sqrt(eps));
            v_out.par = Jacobian_test_v2(@step_test_par,@step_par_test_par,rand(1),rand(size(v_0(1:parameters.ndegf))),sqrt(eps));
        end
        Dv_out = [];
        return
    else
        if isfield(parameters.flags,'identity') && parameters.flags.identity
              v_out  = Jacobian_test_v2(@step_test,@Jacobian_test,ones(size(V_0)),parameters,sqrt(eps));           
        elseif isfield(parameters.flags,'local') && parameters.flags.local
             v_out  = Jacobian_test_v2(@step_test,@Jacobian_test,V_0,parameters,sqrt(eps));           
        else
            v_out  = Jacobian_test_v2(@step_test,@Jacobian_test,rand(size(V_0)),parameters,sqrt(eps));
        end
        return
    end
end

if nargout > 1
    %use supplied solver specification to integrate forward in time
    switch parameters.solver.method
        case '15s'
            [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step_augmented,t_span,V_0,options);
        case '23t'
            [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step_augmented,t_span,V_0,options);
        case '45'
            [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step_augmented,t_span,V_0,options);
    end
else
     switch parameters.solver.method
         case '15s'
            [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step,t_span,V_0,options);
         case '23t'
            [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step,t_span,V_0,options);
         case '45' 
            [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step,t_span,V_0,options);   
     end
end
%test whether orbit crosses nullcline at all
if isempty(tfin), error(strcat('orbit did not return to initial value of degree of freedom #',num2str(parameters.i_crossing))), end
%continue if orbit did not cross nullcline in opposite direction
if length(tfin) < 2
    t_span = t_span + max(t_sol);
    V_0=V_sol(end,:)';
    dv_0dt_init = step(0,v_0(1:parameters.ndegf));
    parameters.dir_crossing = sign(dv_0dt_init);
    parameters.dir_crossing(parameters.i_crossing) = [];    %define direction of flow for the other degrees of freedom at initial point
    %increment initial conditions slightly in flow direction in order not to
    %trigger event function spuriously;
    V_0(1:parameters.ndegf) = V_0(1:parameters.ndegf) + parameters.solver.delta_v_0*dv_0dt_init/norm(dv_0dt_init);
    %repeat integration
    if nargout > 1
        %use supplied solver specification to integrate forward in time
        switch parameters.solver.method
            case '15s'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step_augmented,t_span,V_0,options);
            case '23t'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step_augmented,t_span,V_0,options);
            case '45'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step_augmented,t_span,V_0,options);
        end
    else
        switch parameters.solver.method
            case '15s'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step,t_span,V_0,options);
            case '23t'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step,t_span,V_0,options);
            case '45' 
                [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step,t_span,V_0,options);   
        end
    end
end
%test whether orbit crosses nullcline at all
if ~sum(ifin), error(strcat('orbit did not return to initial value of degree of freedom #',num2str(parameters.i_crossing))), end

%extract final state vector and advected Jacobian
V_sol = V_sol(end,:).';
v_f = V_sol(1:parameters.ndegf);
if nargout > 1
    Dv_f = V_sol(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+2));
    Dv_f = reshape(Dv_f,parameters.ndegf,parameters.ndegf+1);
end

%set up output
v_out = zeros(2*parameters.ndegf,1);
if nargin > 2
    Dv_out = zeros(2*parameters.ndegf,2*parameters.ndegf+1);
end

v_out(1:parameters.ndegf) = v_f-v_0(1:parameters.ndegf);

if nargout > 1
    %Jacobian uncorrected for integration interval length / termination at
    %surface prescribed by crossing
        %Dv_f(1:parameters.ndegf,1:parameters.ndegf) = Dv_f(1:parameters.ndegf,1:parameters.ndegf) - eye(parameters.ndegf);
    %correct for changing interval length controlled by forcing third variable
    %to return to original value:
    dvdt_f = step(t_sol(end),v_f);
    Mass_f = mass(t_sol(end));
    dvdt_f = Mass_f\dvdt_f;   %rate of change of final state with respect to final time
    Dg = Dcrossing(t_sol(end),v_f); %produces a row vector normal to nullcline (gradient vector of function whose zero level set defines nullcline)
    Dv_f = Dv_f - dvdt_f*(Dg*Dv_f)/(Dg*dvdt_f);
    %correct for explicit parameter dependence of nullcline
    Dmug = Dmucrossing(t_sol(end),v_f);
    Dv_f(:,parameters.ndegf+1) = Dv_f(:,parameters.ndegf+1) - dvdt_f*Dmug/(Dg*dvdt_f);
    Dv_f(1:parameters.ndegf,1:parameters.ndegf) = Dv_f(1:parameters.ndegf,1:parameters.ndegf) - eye(parameters.ndegf);
    %arrange output
    Dv_out(1:parameters.ndegf,1:parameters.ndegf) = Dv_f(1:parameters.ndegf,1:parameters.ndegf);
    Dv_out(1:parameters.ndegf,2*parameters.ndegf+1) =  Dv_f(1:parameters.ndegf,parameters.ndegf+1);
end
if nargout == 3
    faux.DvP = Dv_f(1:parameters.ndegf,1:parameters.ndegf)+eye(parameters.ndegf);
    faux.t_orbit = tfin(end);
end

%steady state compoments of output
v_out(parameters.ndegf+1:2*parameters.ndegf) = step(0,v_0(parameters.ndegf+1:2*parameters.ndegf));
Dv_out(parameters.ndegf+1:2*parameters.ndegf,parameters.ndegf+1:2*parameters.ndegf) = Jacobian(0,v_0(parameters.ndegf+1:2*parameters.ndegf));
Dv_out(parameters.ndegf+1:2*parameters.ndegf,2*parameters.ndegf+1) = step_par(0,v_0(parameters.ndegf+1:2*parameters.ndegf));
%this version of the closed orbit solver requires no coordination between steady state and closed orbit problems



function [event_out,isterminal,direction] = crossing(t,v_in)
%Event function that determines when state vector passes through the ith
%nullcline; terminates if the sign of the other components of the flow are
%the same as for the initial condition for the integration. this may not
%correspond to a full loop, so the integartion routine in the main program
%body will continue the integration if the state vector has not also passed
%the nullcline in the other direction (i.e. if there has not been an event
%for which the integration did not terminate
    event_aux = step(t,v_in);
    event_out = event_aux(parameters.i_crossing);
    event_aux(parameters.i_crossing) = [];
    if parameters.dir_crossing == sign(event_aux)
        isterminal = true;
    else
        isterminal = false;
    end
    direction = 0;
end

function Devent = Dcrossing(t,v_in)
%Gradient of first argument of event function with respect to argument v_in
    Devent_aux = Jacobian(t,v_in);
    Devent = Devent_aux(parameters.i_crossing,:);
end

function Dmuevent = Dmucrossing(t,v_in)
%Gradient of first argument of event function with respect to argument v_in
    Devent_aux = step_par(t,v_in);
    Dmuevent = Devent_aux(parameters.i_crossing);
end

function Mass_out = mass_augmented(t)
    Mass_out = kron(eye(parameters.ndegf+2),mass(t));
    Mass_out(parameters.ndegf*(parameters.ndegf+1)+1:parameters.ndegf*(parameters.ndegf+2),1:parameters.ndegf) = Dlmass(t);
end
 
function v_test_out = step_augmented_test(v_in,parameters)
    v_test_out = step_augmented(0,v_in);
end

function v_test_out = step_test(v_in,parameters)
    v_test_out = step(0,v_in);
end

function v_test_out = step_test_par(l_in,v_in)
parameters.c = l_in
v_test_out = step(0,v_in);
end

function v_test_out = step_par_test_par(l_in,v_in)
parameters.c = l_in
v_test_out = step_par(0,v_in);
end

function v_out = step_augmented(t,v_in)
v_out = zeros(parameters.ndegf*(parameters.ndegf+1),1);
F = step(t,v_in(1:parameters.ndegf));
DF = Jacobian(t,v_in(1:parameters.ndegf));
DlF = step_par(t,v_in(1:parameters.ndegf));
v_out(1:parameters.ndegf) = F;
v_out(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1)) = kron(eye(parameters.ndegf),DF)*v_in(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1));
v_out(parameters.ndegf*(parameters.ndegf+1)+1:parameters.ndegf*(parameters.ndegf+2)) = ...
    DlF+DF*v_in(parameters.ndegf*(parameters.ndegf+1)+1:parameters.ndegf*(parameters.ndegf+2));
end

function J_test_out = Jacobian_augmented_test(v_in,parameters)
    J_test_out = Jacobian_augmented(0,v_in);
end

function J_test_out = Jacobian_test(v_in,parameters)
    J_test_out = Jacobian(0,v_in);
end
    
function J_out = Jacobian_augmented(t,v_in)
%Jacobian of parallel_Step with regard to input argument v_in
DF = Jacobian(t,v_in(1:parameters.ndegf));
D2F = DJacobian(t,v_in(1:parameters.ndegf));
D2lF = Jacobian_par(t,v_in(1:parameters.ndegf));
J_out = kron(eye(parameters.ndegf+2),DF);
for ii=1:parameters.ndegf
    J_out(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+2),ii) =  kron(eye(parameters.ndegf+1),D2F(:,:,ii))*v_in(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+2));
end
J_out(parameters.ndegf*(parameters.ndegf+1)+1:parameters.ndegf*(parameters.ndegf+2),1:parameters.ndegf) = ...
    J_out(parameters.ndegf*(parameters.ndegf+1)+1:parameters.ndegf*(parameters.ndegf+2),1:parameters.ndegf) + D2lF; 
end




function m_out = mass(t)
    m_out = eye(parameters.ndegf);
end

function Dm_out = Dlmass(t)
Dm_out = zeros(2);
end
    
function F_out = step(t,v_F_in)
F_out = function_structure.evolve(t,v_F_in,0,parameters.c)
end

function DlF_out = step_par(t,v_DlF_in)
DlF_out = function_structure.steppar(t,v_DlF_in,0);
end

function DF_out = Jacobian(t,v_DF_in)
DF_out = function_structure.evolve(t,v_DF_in,1,parameters.c)
end


function D2lF_out = Jacobian_par(t,v_DF_in)
D2lF_out = function_structure.steppar(t,v_DF_in,1);
end

function D2F_out = DJacobian(t,v_D2F_in)
D2F_out = function_structure.evolve(t,v_D2F_in,2,parameters.c)
end

end