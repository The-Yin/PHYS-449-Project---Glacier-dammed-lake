function [v_out, Dv_out, faux] = shoot_method(v_0,parameters,functions_structure)
%[v_out Dv_out] = ttt_shoot_nullcline(v_0,parameters)
%Also outputs Jacobian of the final state vector as a function of the
%initial state vector, if two  output arguments are specified.
%
% All quantities other than the initial state vector are specified as parameters.
%
%Input variables are
%   v_0:     3-by-1 vector containing initial state vector [S_R; S_K; N]
%   parameters: optional parameter structure with fields
%       t_span: 2-by-1 vector specifying initial and final time for
%               integration; only needs to be long enough for the variable
%               with index i_crossing (1 for S_R, 2 for S_K, 3 for N) to
%               return to its original state and the corresponding flow
%               component (in the dynamical systems sense) to be in the same
%               direction as at the start of the integration. Forward
%               integration terminates at that point.
%       solver: optional substructure with fields
%           methods: string that specifies the matlab ode solver to be used,
%               allows '15s', '23t' and '45'. Defaults to 15s.
%           RelTol: specifies 'RelTol' relative error tolerance passed to
%               matlab ode solver
%           AbsTol: specifies 'AbsTol' absolute error tolerance passed to
%               matlab ode solver
%           delta_v_0: the code displaces the intial conditions by this
%               amount in the flow direction before starting integration,
%               to avoid spurious "return to initial value" right at the
%               start of the integration. Defaults to 100*eps;
%       flags: optional substructure that allows a Jacobian test to be
%               computed. If a field 'test' under flags is set to true, the
%               output v_f is a structure that contains the following
%               fields as generated by Jacobian_test_v2
%           diff:   analytically-computed derivative matrix
%           diff_num: numericallu-computed derivative matrix
%           error:  element-wise error in numerically-computed
%                   derivative matrix
%           error_norm: matrix norm of difference between diff and
%                   diff_num, scaled to norm of diff
%               if 'test' is not set but an alternative field 'plot' is
%               set, output of forward integration is plotted as in the
%               (S_R,N) phase plane
%       i_crossing: specifies which nullcline defines Poincare map 
%
%       functions_structure: contain evolve and event
%
%Output:
%   v_out:        Difference between final and initial state vectors [S_R; S_K; N]
%   Dv_out:       Jacobian of v_f with respect to v_0 (optional)
%   faux:         Optional structure with additional information on closed
%                 orbit, with fields
%       DvP:      When [S_R; S_K; N] is a fixed point of the Poincare map,
%                 this returns the Jacobian of Poincare map as a 3-by-3
%                 matrix; as the Poincare map is defined on a
%                 two-dimensional manifold, DvP has a nullspace (given by
%                 the flow direction of the dynamical system at the fixed
%                 point) and  hence  a zero eigenvalue.
%       t_orbit:  period of orbit
%
%Works as parallel_shoot_v6 but computes Jacobian of Poincare map with a
%nullspace (given by the flow direction at the fixed point) and uses
%nullcline to define Poincare map





%set mass matrix and Jacobian
if nargout > 1
    options = odeset('Mass',@mass_augmented,'MStateDep','none','Jacobian',@Jacobian_augmented,'RelTol',parameters.solver.RelTol,'AbsTol',parameters.solver.AbsTol,'Events',@crossing);
else
    options = odeset('Mass',@mass,'MStateDep','none','Jacobian',@Jacobian,'RelTol',parameters.solver.RelTol,'AbsTol',parameters.solver.AbsTol,'Events',@crossing);
end    
    
    
t_span = parameters.t_span;


%Establish number of degrees of freedom
parameters.ndegf = length(v_0);

if nargout > 1
    %Construct augmented initial conditions
    V_0 = zeros(parameters.ndegf*(parameters.ndegf+1),1);
    disp(V_0(1:parameters.ndegf))
    disp(v_0)
    V_0(1:parameters.ndegf) = v_0; %terms corresponding to input state vector v_0
    V_0(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1)) = reshape(eye(parameters.ndegf),parameters.ndegf^2,1); %now add terms corresponding to Jacobian with respect to state vector
else
    V_0 = v_0;
end
    

dv_0dt_init = step(0,v_0(1:parameters.ndegf));
parameters.dir_crossing = sign(dv_0dt_init);
parameters.dir_crossing(parameters.i_crossing) = [];    %define direction of flow for the other degrees of freedom at initial point

%Test Jacobian (optional)
if nargin > 1 && isfield(parameters,'flags') && isfield(parameters.flags,'test') && parameters.flags.test
    if nargout > 1
        if isfield(parameters.flags,'identity') && parameters.flags.identity
            v_out = Jacobian_test_v2(@step_augmented_test,@Jacobian_augmented_test,[ones(parameters.ndegf,1); reshape(eye(parameters.ndegf),parameters.ndegf^2,1)],parameters,sqrt(eps));
        else
            v_out = Jacobian_test_v2(@step_augmented_test,@Jacobian_augmented_test,rand(size(V_0)),parameters,sqrt(eps));
        end
        Dv_out = [];
        return
    else
        v_out  = Jacobian_test_v2(@step_test,@Jacobian_test,rand(size(V_0)),parameters,sqrt(eps));
        return
    end
end

if nargout > 1
    %use supplied solver specification to integrate forward in time
    if strcmp(parameters.solver.method,'15s')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step_augmented,t_span,V_0,options);
    elseif strcmp(parameters.solver.method,'23t')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step_augmented,t_span,V_0,options);
    elseif strcmp(parameters.solver.method,'45')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step_augmented,t_span,V_0,options);
    end
else
     if strcmp(parameters.solver.method,'15s')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step,t_span,V_0,options);
    elseif strcmp(parameters.solver.method,'23t')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step,t_span,V_0,options);
    elseif strcmp(parameters.solver.method,'45')
        [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step,t_span,V_0,options);   
     end
end
if nargin > 1 && isfield(parameters,'flags') && isfield(parameters.flags,'plot') && parameters.flags.plot
    disp('first orbit plot')
    disp(tfin)
    disp(parameters.dir_crossing)
    %disp(Vfin)
    for jj=1:length(tfin)
        disp(step(tfin(jj),Vfin(jj,:).'))
    end
    figure, hold on
    plot(V_sol(:,1),V_sol(:,3),'b')
end
%test whether orbit crosses nullcline at all
if isempty(tfin), error(strcat('orbit did not return to initial value of degree of freedom #',num2str(parameters.i_crossing))), end
%continue if orbit did not cross nullcline in opposite direction
if length(tfin) < 2
    t_span = t_span + max(t_sol);
    V_0=V_sol(end,:)';
    dv_0dt_init = step(0,V_0(1:parameters.ndegf));
    parameters.dir_crossing = sign(dv_0dt_init);
    parameters.dir_crossing(parameters.i_crossing) = [];    %define direction of flow for the other degrees of freedom at initial point
    %increment initial conditions slightly in flow direction in order not to
    %trigger event function spuriously;
    V_0(1:parameters.ndegf) = V_0(1:parameters.ndegf) + parameters.solver.delta_v_0*dv_0dt_init/norm(dv_0dt_init);
    %repeat integration
    if nargout > 1
        %use supplied solver specification to integrate forward in time
        switch parameters.solver.method
            case '15s'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step_augmented,t_span,V_0,options);
            case '23t'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step_augmented,t_span,V_0,options);
            case '45'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step_augmented,t_span,V_0,options);
        end
    else
        switch parameters.solver.method
            case '15s'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode15s(@step,t_span,V_0,options);
            case '23t'
                [t_sol, V_sol, tfin, Vfin, ifin] = ode23t(@step,t_span,V_0,options);
            case '45' 
                [t_sol, V_sol, tfin, Vfin, ifin] = ode45(@step,t_span,V_0,options);   
        end
    end
if nargin > 1 && isfield(parameters,'flags') && isfield(parameters.flags,'plot') && parameters.flags.plot
    disp('continued orbit plot')
    plot(V_sol(:,1),V_sol(:,3),'r')
end
end

%test whether orbit crosses nullcline at all
if ~sum(ifin), error(strcat('orbit did not return to initial value of degree of freedom #',num2str(parameters.i_crossing))), end


%extract final state vector and advected Jacobian
V_sol = V_sol(end,:).';
v_f = V_sol(1:parameters.ndegf);


if nargout > 1
    Dv_f = V_sol(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1));
    Dv_f = reshape(Dv_f,parameters.ndegf,parameters.ndegf);
end
    
%function for rootfinding: difference  between initial and final state
v_out = v_f-v_0;

disp('OOOOOOOOOOOOOOOO 1')
disp(v_f)
disp('OOOOOOOOOOOOOOOO 2')
disp(v_0')
disp('OOOOOOOOOOOOOOOO 3')
disp(v_out)









if nargout > 1
    %Jacobian uncorrected for integration interval length / termination at
    %surface prescribed by crossing
    Dv_f(1:parameters.ndegf,1:parameters.ndegf) = Dv_f(1:parameters.ndegf,1:parameters.ndegf);
    %correct for changing interval length controlled by forcing third variable
    %to return to original value:
    dvdt_f = step(t_sol(end),v_f);
    Mass_f = mass(t_sol(end));
    dvdt_f = Mass_f\dvdt_f;   %rate of change of final state with respect to final time
    Dg = Dcrossing(t_sol(end),v_f); %produces a row vector normal to nullcline (gradient vector of function whose zero level set defines nullcline)
    Dv_f = Dv_f - dvdt_f*(Dg*Dv_f)/(Dg*dvdt_f);
    Dv_f(1:parameters.ndegf,1:parameters.ndegf) = Dv_f(1:parameters.ndegf,1:parameters.ndegf) - eye(parameters.ndegf);
    %arrange output
    Dv_out = Dv_f;
end
if nargout == 3
    faux.DvP = Dv_f(1:parameters.ndegf,1:parameters.ndegf)+eye(parameters.ndegf);
    faux.t_orbit = tfin(end);
end

    
%%%%%%non-problem specific functions, re-route to problem-specific functions
%below
function [event_out,isterminal,direction] = crossing(t,v_in)
%Event function that determines when state vector passes through the ith
%nullcline; terminates if the sign of the other components of the flow are
%the same as for the initial condition for the integration. this may not
%correspond to a full loop, so the integartion routine in the main program
%body will continue the integration if the state vector has not also passed
%the nullcline in the other direction (i.e. if there has not been an event
%for which the integration did not terminate
    event_aux = step(t,v_in);
    event_out = event_aux(parameters.i_crossing);
    event_aux(parameters.i_crossing) = [];
    if parameters.dir_crossing == sign(event_aux)
        isterminal = true;
    else
        isterminal = false;
    end
    direction = 0;
end

function Devent = Dcrossing(t,v_in)
%Gradient of first argument of event function with respect to argument v_in
    Devent_aux = Jacobian(t,v_in);
    Devent = Devent_aux(parameters.i_crossing,:);
end

function Mass_out = mass_augmented(t)
    Mass_out = kron(eye(parameters.ndegf+1),mass(t));
end
 
function v_test_out = step_augmented_test(v_in,parameters)
    v_test_out = step_augmented(0,v_in);
end

function v_test_out = step_test(v_in,parameters)
    v_test_out = step(0,v_in);
end

function v_out = step_augmented(t,v_in)
v_out = zeros(parameters.ndegf*(parameters.ndegf+1),1);
F = step(t,v_in(1:parameters.ndegf));
DF = Jacobian(t,v_in(1:parameters.ndegf));
v_out(1:parameters.ndegf) = F;
v_out(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1)) = kron(eye(parameters.ndegf),DF)*v_in(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1));
end

function J_test_out = Jacobian_augmented_test(v_in,parameters)
    J_test_out = Jacobian_augmented(0,v_in);
end

function J_test_out = Jacobian_test(v_in,parameters)
    J_test_out = Jacobian(0,v_in);
end
    
function J_out = Jacobian_augmented(t,v_in)
%Jacobian of parallel_Step with regard to input argument v_in
DF = Jacobian(t,v_in(1:parameters.ndegf));
D2F = DJacobian(t,v_in(1:parameters.ndegf));
J_out = kron(eye(parameters.ndegf+1),DF);
for ii=1:parameters.ndegf
    J_out(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1),ii) =  kron(eye(parameters.ndegf),D2F(:,:,ii))*v_in(parameters.ndegf+1:parameters.ndegf*(parameters.ndegf+1),1);
end
end

%%%%%%%%%%%%%%%%%%%%Problem-specific functions
function m_out = mass(t)
    m_out = eye(parameters.ndegf);
end
    
function F_out = step(t,v_F_in)
F_out = functions_structure.evolve(t,v_F_in,0,parameters.c)
end

function DF_out = Jacobian(t,v_DF_in)
DF_out = functions_structure.evolve(t,v_DF_in,1,parameters.c);
end

function D2F_out = DJacobian(t,v_D2F_in)
D2F_out = functions_structure.evolve(t,v_D2F_in,2,parameters.c);
end

end
